/**
 * Jogo da Velha Interativo - UC9
 * L√≥gica de Programa√ß√£o e Algoritmos
 * 
 * Este arquivo implementa:
 * - Vari√°veis e constantes
 * - Estruturas de controle (if/else, loops)
 * - Fun√ß√µes e modulariza√ß√£o
 * - Arrays para representa√ß√£o do tabuleiro
 * - Objetos para organiza√ß√£o do c√≥digo
 * - Eventos e manipula√ß√£o do DOM
 * - Algoritmos de verifica√ß√£o de vit√≥ria/empate
 */

// ===== CONSTANTES =====
const SIMBOLO_X = 'X';
const SIMBOLO_O = 'O';
const CELULA_VAZIA = '';
const TAMANHO_TABULEIRO = 3;

// ===== VARI√ÅVEIS GLOBAIS =====
let tabuleiro = [];
let jogadorAtual = SIMBOLO_X;
let jogoAtivo = true;
let celulas = [];

// ===== ELEMENTOS DO DOM =====
const tabuleiroElement = document.getElementById('tabuleiro');
const jogadorAtualElement = document.getElementById('jogadorAtual');
const statusMensagemElement = document.getElementById('statusMensagem');
const btnReiniciarElement = document.getElementById('btnReiniciar');

// ===== INICIALIZA√á√ÉO DO JOGO =====
document.addEventListener('DOMContentLoaded', () => {
  inicializarJogo();
  configurarEventListeners();
});

/**
 * Inicializa o estado inicial do jogo
 */
function inicializarJogo() {
  // Inicializa o tabuleiro como array 2D vazio
  tabuleiro = [];
  for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
    tabuleiro[i] = [];
    for (let j = 0; j < TAMANHO_TABULEIRO; j++) {
      tabuleiro[i][j] = CELULA_VAZIA;
    }
  }

  // Reseta vari√°veis do jogo
  jogadorAtual = SIMBOLO_X;
  jogoAtivo = true;

  // Cria as c√©lulas do tabuleiro
  criarCelulasTabuleiro();

  // Atualiza a interface
  atualizarInterface();
}

/**
 * Cria dinamicamente as c√©lulas do tabuleiro
 */
function criarCelulasTabuleiro() {
  tabuleiroElement.innerHTML = '';
  celulas = [];

  for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
    for (let j = 0; j < TAMANHO_TABULEIRO; j++) {
      const celula = document.createElement('div');
      celula.className = 'cell';
      celula.setAttribute('data-row', i);
      celula.setAttribute('data-col', j);
      celula.setAttribute('tabindex', '0');
      celula.setAttribute('role', 'button');
      celula.setAttribute('aria-label', `C√©lula ${i + 1}, ${j + 1}`);

      tabuleiroElement.appendChild(celula);
      celulas.push(celula);
    }
  }
}

/**
 * Configura todos os event listeners do jogo
 */
function configurarEventListeners() {
  // Event listener para cliques nas c√©lulas
  tabuleiroElement.addEventListener('click', lidarComClique);

  // Event listener para navega√ß√£o por teclado
  tabuleiroElement.addEventListener('keydown', lidarComTeclado);

  // Event listener para o bot√£o de rein√≠cio
  btnReiniciarElement.addEventListener('click', reiniciarJogo);
}

/**
 * Manipula cliques nas c√©lulas do tabuleiro
 * @param {Event} evento - Evento de clique
 */
function lidarComClique(evento) {
  const celula = evento.target;

  // Verifica se o clique foi em uma c√©lula v√°lida
  if (!celula.classList.contains('cell') || !jogoAtivo) {
    return;
  }

  const row = parseInt(celula.getAttribute('data-row'));
  const col = parseInt(celula.getAttribute('data-col'));

  // Verifica se a c√©lula est√° vazia
  if (tabuleiro[row][col] === CELULA_VAZIA) {
    fazerJogada(row, col);
  }
}

/**
 * Manipula navega√ß√£o por teclado nas c√©lulas
 * @param {KeyboardEvent} evento - Evento de teclado
 */
function lidarComTeclado(evento) {
  if (evento.key === 'Enter' || evento.key === ' ') {
    evento.preventDefault();
    lidarComClique(evento);
  }
}

/**
 * Executa uma jogada v√°lida
 * @param {number} row - Linha da c√©lula
 * @param {number} col - Coluna da c√©lula
 */
function fazerJogada(row, col) {
  // Atualiza o tabuleiro
  tabuleiro[row][col] = jogadorAtual;

  // Atualiza a interface da c√©lula
  const celula = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
  celula.textContent = jogadorAtual;
  celula.classList.add(jogadorAtual.toLowerCase());

  // Verifica condi√ß√µes de fim de jogo
  if (verificarVitoria(row, col)) {
    finalizarJogo('vitoria');
  } else if (verificarEmpate()) {
    finalizarJogo('empate');
  } else {
    // Alterna para o pr√≥ximo jogador
    alternarJogador();
    atualizarInterface();
  }
}

/**
 * Verifica se a jogada atual resultou em vit√≥ria
 * @param {number} row - Linha da √∫ltima jogada
 * @param {number} col - Coluna da √∫ltima jogada
 * @returns {boolean} True se houve vit√≥ria
 */
function verificarVitoria(row, col) {
  const simbolo = tabuleiro[row][col];

  // Verifica linha
  if (verificarLinha(row, simbolo)) {
    destacarLinhaVencedora(row, 'horizontal');
    return true;
  }

  // Verifica coluna
  if (verificarColuna(col, simbolo)) {
    destacarLinhaVencedora(col, 'vertical');
    return true;
  }

  // Verifica diagonais (apenas se a jogada foi em uma diagonal)
  if (row === col && verificarDiagonalPrincipal(simbolo)) {
    destacarLinhaVencedora(null, 'diagonal-principal');
    return true;
  }

  if (row + col === TAMANHO_TABULEIRO - 1 && verificarDiagonalSecundaria(simbolo)) {
    destacarLinhaVencedora(null, 'diagonal-secundaria');
    return true;
  }

  return false;
}

/**
 * Verifica se uma linha est√° completa com o mesmo s√≠mbolo
 * @param {number} row - √çndice da linha
 * @param {string} simbolo - S√≠mbolo a verificar
 * @returns {boolean} True se a linha est√° completa
 */
function verificarLinha(row, simbolo) {
  for (let col = 0; col < TAMANHO_TABULEIRO; col++) {
    if (tabuleiro[row][col] !== simbolo) {
      return false;
    }
  }
  return true;
}

/**
 * Verifica se uma coluna est√° completa com o mesmo s√≠mbolo
 * @param {number} col - √çndice da coluna
 * @param {string} simbolo - S√≠mbolo a verificar
 * @returns {boolean} True se a coluna est√° completa
 */
function verificarColuna(col, simbolo) {
  for (let row = 0; row < TAMANHO_TABULEIRO; row++) {
    if (tabuleiro[row][col] !== simbolo) {
      return false;
    }
  }
  return true;
}

/**
 * Verifica se a diagonal principal est√° completa
 * @param {string} simbolo - S√≠mbolo a verificar
 * @returns {boolean} True se a diagonal est√° completa
 */
function verificarDiagonalPrincipal(simbolo) {
  for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
    if (tabuleiro[i][i] !== simbolo) {
      return false;
    }
  }
  return true;
}

/**
 * Verifica se a diagonal secund√°ria est√° completa
 * @param {string} simbolo - S√≠mbolo a verificar
 * @returns {boolean} True se a diagonal est√° completa
 */
function verificarDiagonalSecundaria(simbolo) {
  for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
    if (tabuleiro[i][TAMANHO_TABULEIRO - 1 - i] !== simbolo) {
      return false;
    }
  }
  return true;
}

/**
 * Verifica se o jogo terminou em empate
 * @returns {boolean} True se √© empate
 */
function verificarEmpate() {
  for (let row = 0; row < TAMANHO_TABULEIRO; row++) {
    for (let col = 0; col < TAMANHO_TABULEIRO; col++) {
      if (tabuleiro[row][col] === CELULA_VAZIA) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Destaca visualmente a linha vencedora
 * @param {number|null} index - √çndice da linha/coluna (null para diagonais)
 * @param {string} tipo - Tipo de linha ('horizontal', 'vertical', 'diagonal-principal', 'diagonal-secundaria')
 */
function destacarLinhaVencedora(index, tipo) {
  const celulasVencedoras = [];

  switch (tipo) {
    case 'horizontal':
      for (let col = 0; col < TAMANHO_TABULEIRO; col++) {
        const celula = document.querySelector(`[data-row="${index}"][data-col="${col}"]`);
        celulasVencedoras.push(celula);
      }
      break;

    case 'vertical':
      for (let row = 0; row < TAMANHO_TABULEIRO; row++) {
        const celula = document.querySelector(`[data-row="${row}"][data-col="${index}"]`);
        celulasVencedoras.push(celula);
      }
      break;

    case 'diagonal-principal':
      for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
        const celula = document.querySelector(`[data-row="${i}"][data-col="${i}"]`);
        celulasVencedoras.push(celula);
      }
      break;

    case 'diagonal-secundaria':
      for (let i = 0; i < TAMANHO_TABULEIRO; i++) {
        const celula = document.querySelector(`[data-row="${i}"][data-col="${TAMANHO_TABULEIRO - 1 - i}"]`);
        celulasVencedoras.push(celula);
      }
      break;
  }

  // Aplica a classe de destaque
  celulasVencedoras.forEach(celula => {
    celula.classList.add('winning');
  });
}

/**
 * Alterna para o pr√≥ximo jogador
 */
function alternarJogador() {
  jogadorAtual = jogadorAtual === SIMBOLO_X ? SIMBOLO_O : SIMBOLO_X;
}

/**
 * Finaliza o jogo com o resultado especificado
 * @param {string} resultado - Tipo de resultado ('vitoria' ou 'empate')
 */
function finalizarJogo(resultado) {
  jogoAtivo = false;

  if (resultado === 'vitoria') {
    statusMensagemElement.textContent = `üéâ Jogador ${jogadorAtual} venceu!`;
    statusMensagemElement.style.borderLeftColor = 'var(--accent-secondary)';
  } else if (resultado === 'empate') {
    statusMensagemElement.textContent = 'ü§ù Empate! Ningu√©m venceu.';
    statusMensagemElement.style.borderLeftColor = 'var(--accent-danger)';
  }

  // Desabilita todas as c√©lulas
  celulas.forEach(celula => {
    celula.classList.add('disabled');
  });
}

/**
 * Atualiza a interface do jogo
 */
function atualizarInterface() {
  // Atualiza o s√≠mbolo do jogador atual
  jogadorAtualElement.textContent = jogadorAtual;

  // Atualiza a cor do s√≠mbolo baseada no jogador
  if (jogadorAtual === SIMBOLO_X) {
    jogadorAtualElement.style.color = 'var(--accent-primary)';
    jogadorAtualElement.style.borderColor = 'var(--accent-primary)';
  } else {
    jogadorAtualElement.style.color = 'var(--accent-secondary)';
    jogadorAtualElement.style.borderColor = 'var(--accent-secondary)';
  }

  // Atualiza a mensagem de status
  if (jogoAtivo) {
    statusMensagemElement.textContent = `Vez do jogador ${jogadorAtual}`;
    statusMensagemElement.style.borderLeftColor = 'var(--accent-primary)';
  }
}

/**
 * Reinicia o jogo para uma nova partida
 */
function reiniciarJogo() {
  // Remove classes de destaque das c√©lulas
  celulas.forEach(celula => {
    celula.classList.remove('x', 'o', 'winning', 'disabled');
    celula.textContent = '';
  });

  // Reinicializa o jogo
  inicializarJogo();

  // Adiciona anima√ß√£o de rein√≠cio
  btnReiniciarElement.style.transform = 'rotate(360deg)';
  setTimeout(() => {
    btnReiniciarElement.style.transform = 'rotate(0deg)';
  }, 300);
}

// ===== FUNCIONALIDADES EXTRAS (Aula 9) =====

/**
 * Alterna entre tema claro e escuro
 */
function alternarTema() {
  const temaAtual = document.documentElement.getAttribute('data-theme');
  const novoTema = temaAtual === 'dark' ? 'light' : 'dark';

  document.documentElement.setAttribute('data-theme', novoTema);

  // Salva prefer√™ncia no localStorage
  localStorage.setItem('tema', novoTema);
}

/**
 * Carrega o tema salvo do localStorage
 */
function carregarTemaSalvo() {
  const temaSalvo = localStorage.getItem('tema');
  if (temaSalvo) {
    document.documentElement.setAttribute('data-theme', temaSalvo);
  }
}

/**
 * Adiciona som para jogadas (simulado com console.log)
 */
function tocarSomJogada() {
  console.log('üîä Som de jogada tocado!');
  // Em uma implementa√ß√£o real, aqui seria usado Web Audio API
}

/**
 * Adiciona som para vit√≥ria (simulado com console.log)
 */
function tocarSomVitoria() {
  console.log('üéµ Som de vit√≥ria tocado!');
  // Em uma implementa√ß√£o real, aqui seria usado Web Audio API
}

// Carrega tema salvo ao inicializar
carregarTemaSalvo();

// Adiciona som √†s jogadas
const somOriginal = fazerJogada;
fazerJogada = function (row, col) {
  tocarSomJogada();
  somOriginal(row, col);
};

// Adiciona som √†s vit√≥rias
const finalizarOriginal = finalizarJogo;
finalizarJogo = function (resultado) {
  if (resultado === 'vitoria') {
    tocarSomVitoria();
  }
  finalizarOriginal(resultado);
};
